generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "mongodb"
  url      = env("DATABASE_URL")
}

/**
 * ---------- Enums ----------
 */

enum UserRole {
  USER
  ADMIN
}

enum BotStatus {
  DRAFT
  TRAINING
  DEPLOYED
  DISABLED
}

enum LeadStatus {
  NEW
  CONTACTED
  QUALIFIED
  CONVERTED
  LOST
}

enum IntegrationType {
  WHATSAPP
  MESSENGER
  FACEBOOK
  GOOGLE_CALENDAR
  MICROSOFT_CALENDAR
  SALESFORCE
  GOOGLE_SHEETS
}

enum SubscriptionStatus {
  ACTIVE
  PAST_DUE
  CANCELED
  TRIALING
  UNPAID
}

enum PaymentStatus {
  SUCCEEDED
  PENDING
  FAILED
  REFUNDED
}

enum BlogStatus {
  DRAFT
  PUBLISHED
  ARCHIVED
}

enum PlanName {
  FREE
  STARTER
  PRO
  ENTERPRISE
}

/**
 * Cache types for optional DB-backed cache entries (Redis recommended for runtime)
 */
enum CacheType {
  LLM_RESPONSE // e.g. text reply from LLM for a prompt
  EMBEDDING // cached embedding vector (if you ever want persistent copy)
  CRAWL_RESULT // crawled site text
  TTS_AUDIO // precomputed TTS audio (small blobs OR URL)
  OPENROUTER_TOKEN // cached token if you use token exchange logic (short lived)
  GENERIC // fallback / misc
}

/**
 * ---------- NextAuth / user auth models ----------
 * Note: keep tokens encrypted or prefer not to store long-lived secrets in DB.
 */

model User {
  id            String    @id @default(auto()) @map("_id") @db.ObjectId
  name          String?
  email         String    @unique
  emailVerified DateTime?
  password      String?
  image         String?
  role          UserRole  @default(USER)
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  stripeCustomerId String?

  accounts       Account[]
  sessions       Session[]
  bots           Bot[]
  leads          Lead[]
  knowledgeBases KnowledgeBase[]
  subscriptions  Subscription[]
  payments       Payment[]
  blogPosts      BlogPost[]
  auditLogs      AuditLog[]
  voiceProfiles  VoiceProfile[]
  uploadedFiles  UploadedFile[]
  integrations   Integration[]
  usage          Usage[]
}

model Account {
  id                String  @id @default(auto()) @map("_id") @db.ObjectId
  userId            String  @db.ObjectId
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(auto()) @map("_id") @db.ObjectId
  sessionToken String   @unique
  userId       String   @db.ObjectId
  expires      DateTime

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model VerificationToken {
  id         String   @id @default(auto()) @map("_id") @db.ObjectId
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

/**
 * ---------- Application models ----------
 */

model Bot {
  id          String    @id @default(auto()) @map("_id") @db.ObjectId
  userId      String    @db.ObjectId
  name        String
  description String?
  status      BotStatus @default(DRAFT)
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  user           User            @relation(fields: [userId], references: [id], onDelete: Cascade)
  knowledgeBases KnowledgeBase[]
  voiceProfiles  VoiceProfile[]
  usage          Usage[]
  config         Json?

  @@index([userId])
}

model KnowledgeBase {
  id          String      @id @default(auto()) @map("_id") @db.ObjectId
  userId      String      @db.ObjectId
  botId       String?     @db.ObjectId
  title       String
  description String?
  source      String? // e.g., "url", "upload", "manual"
  documents   Document[]
  embeddings  Embedding[]
  metadata    Json?
  rawJson     Json?
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  bot  Bot? @relation(fields: [botId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([botId])
}

model Document {
  id        String   @id @default(auto()) @map("_id") @db.ObjectId
  kbId      String   @db.ObjectId
  filename  String?
  mimeType  String?
  size      Int?
  content   String? // extracted text or small content
  sourceUrl String? // if crawled
  metadata  Json?
  createdAt DateTime @default(now())

  kb KnowledgeBase @relation(fields: [kbId], references: [id], onDelete: Cascade)

  @@index([kbId])
}

model Embedding {
  id        String   @id @default(auto()) @map("_id") @db.ObjectId
  kbId      String   @db.ObjectId
  vector    Json // numeric array as JSON
  text      String?
  meta      Json?
  createdAt DateTime @default(now())

  kb KnowledgeBase @relation(fields: [kbId], references: [id], onDelete: Cascade)

  @@index([kbId])
}

model Lead {
  id         String     @id @default(auto()) @map("_id") @db.ObjectId
  userId     String     @db.ObjectId
  name       String?
  email      String?
  phone      String?
  status     LeadStatus @default(NEW)
  source     String?
  capturedBy String? // bot id or channel
  meta       Json?
  createdAt  DateTime   @default(now())
  updatedAt  DateTime   @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

/**
 * Integrations: store oauth / webhook status (keep only what's needed)
 */
model Integration {
  id          String          @id @default(auto()) @map("_id") @db.ObjectId
  userId      String          @db.ObjectId
  type        IntegrationType
  provider    String
  enabled     Boolean         @default(false)
  credentials Json? // store tokens encrypted or truncated
  meta        Json?
  createdAt   DateTime        @default(now())
  updatedAt   DateTime        @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

/**
 * Billing / Plans
 */
model Plan {
  id              String   @id @default(auto()) @map("_id") @db.ObjectId
  name            PlanName @unique
  title           String
  description     String?
  price           String // human readable e.g. "$19 / month"
  priceAmount     Int? // integer cents (e.g. 1900)
  interval        String? // "month" | "year" (optional)
  stripePriceId   String? // stripe price id (price_...)
  minutesPerMonth Int
  agents          Int
  features        String[]
  popular         Boolean  @default(false)
  createdAt       DateTime @default(now())

  subscriptions Subscription[]
}

model Subscription {
  id                   String             @id @default(auto()) @map("_id") @db.ObjectId
  userId               String             @db.ObjectId
  planId               String             @db.ObjectId
  stripeSubscriptionId String?            @unique
  status               SubscriptionStatus @default(TRIALING)
  currentPeriodStart   DateTime?
  currentPeriodEnd     DateTime?
  cancelAtPeriodEnd    Boolean            @default(false)
  meta                 Json?
  createdAt            DateTime           @default(now())
  updatedAt            DateTime           @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  plan Plan @relation(fields: [planId], references: [id])

  @@index([userId])
  @@index([planId])
}

model Payment {
  id                String        @id @default(auto()) @map("_id") @db.ObjectId
  userId            String        @db.ObjectId
  amount            Float
  currency          String
  provider          String
  providerPaymentId String?
  status            PaymentStatus
  meta              Json?
  createdAt         DateTime      @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

/**
 * Blog management
 */
model BlogPost {
  id          String     @id @default(auto()) @map("_id") @db.ObjectId
  title       String
  slug        String     @unique
  excerpt     String?
  content     String
  status      BlogStatus @default(DRAFT)
  authorId    String     @db.ObjectId
  tags        Json?
  coverImage  String?
  createdAt   DateTime   @default(now())
  updatedAt   DateTime   @updatedAt
  publishedAt DateTime?

  author User @relation(fields: [authorId], references: [id], onDelete: Cascade)

  @@index([authorId])
}

/**
 * Audit & logs
 */
model AuditLog {
  id        String   @id @default(auto()) @map("_id") @db.ObjectId
  userId    String?  @db.ObjectId
  action    String
  meta      Json?
  ip        String?
  createdAt DateTime @default(now())

  user User? @relation(fields: [userId], references: [id], onDelete: SetNull)

  @@index([userId])
}

/**
 * Site-wide settings
 */
model SiteSetting {
  id           String   @id @default(auto()) @map("_id") @db.ObjectId
  key          String   @unique
  siteTitle    String?
  siteDesc     String?
  logoUrl      String?
  faviconUrl   String?
  contactEmail String?
  supportEmail String?
  analytics    Json?
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
}

/**
 * Voice profiles (voice cloning, TTS configs)
 */
model VoiceProfile {
  id        String   @id @default(auto()) @map("_id") @db.ObjectId
  userId    String   @db.ObjectId
  botId     String?  @db.ObjectId
  name      String
  model     String?
  config    Json?
  status    String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  bot  Bot? @relation(fields: [botId], references: [id], onDelete: SetNull)

  @@index([userId])
  @@index([botId])
}

/**
 * Usage / analytics (simple)
 */
model Usage {
  id           String   @id @default(auto()) @map("_id") @db.ObjectId
  botId        String?  @db.ObjectId
  userId       String?  @db.ObjectId
  date         DateTime
  interactions Int
  minutes      Int
  meta         Json?
  createdAt    DateTime @default(now())

  bot  Bot?  @relation(fields: [botId], references: [id], onDelete: SetNull)
  user User? @relation(fields: [userId], references: [id], onDelete: SetNull)

  @@index([botId])
  @@index([userId])
  @@index([date])
}

/**
 * Uploaded files metadata (if using Firebase/S3)
 */
model UploadedFile {
  id        String   @id @default(auto()) @map("_id") @db.ObjectId
  userId    String   @db.ObjectId
  filename  String
  fileType  String?
  size      Int?
  url       String
  meta      Json?
  createdAt DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

/**
 * Optional DB-backed cache entries (you can use this for long-lived caches,
 * debugging, or when you don't want to rely solely on Redis).
 * Reminder: prefer Redis for fast TTL-based cache; use this model only if
 * you need persisted cached artifacts.
 */
model CacheEntry {
  id         String    @id @default(auto()) @map("_id") @db.ObjectId
  key        String    @unique
  type       CacheType @default(GENERIC)
  value      Json
  ttlSeconds Int? // optional TTL in seconds (for bookkeeping)
  expiresAt  DateTime? // optional explicit expiry
  meta       Json?
  userId     String?   @db.ObjectId
  createdAt  DateTime  @default(now())
  updatedAt  DateTime  @updatedAt

  @@index([type])
  @@index([expiresAt])
}
